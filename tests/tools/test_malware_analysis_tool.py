"""Tests for the MalwareAnalysisTool."""

import hashlib
import os
import tempfile
import unittest
from unittest.mock import MagicMock, patch

import pytest
import requests  # Import requests directly for exception type
import yaml

# Ensure the tool can be imported
from tools.malware_analysis_tool.malware_analysis_tool import (
    TOOL_CONFIG_PATH,
    MalwareAnalysisTool,
)

# --- Constants and Sample Data ---
SAMPLE_CLEAN_SHA256 = "a" * 64
SAMPLE_MD5 = "b" * 32
SAMPLE_SHA1 = "c" * 40
EICAR_SHA256 = "275a021bbfb6489e54d471899f7db9d1663fc695ec2fe2a2c4538aabf651fd0f"

# Sample API responses (simplified JSON strings)
# Note: Real API responses are more complex
VT_HASH_RESPONSE_CLEAN = '{"data": {"attributes": {"last_analysis_stats": {"malicious": 0, "suspicious": 0, "undetected": 70}}}}'
VT_HASH_RESPONSE_MALICIOUS = '{"data": {"attributes": {"last_analysis_stats": {"malicious": 55, "suspicious": 1, "undetected": 15}}}}'
HA_HASH_RESPONSE_CLEAN = '[{"threat_score": null, "verdict": "no-threat"}]'
HA_HASH_RESPONSE_MALICIOUS = '[{"threat_score": 100, "verdict": "malicious"}]'
VT_ERROR_RESPONSE = '{"error": {"message": "Not found", "code": "NotFoundError"}}'
HA_ERROR_RESPONSE = '{"message": "Invalid hash"}'


# --- Test Class ---
class TestMalwareAnalysisTool(unittest.TestCase):
    """Test suite for MalwareAnalysisTool."""

    @classmethod
    def setUpClass(cls):
        """Set up necessary mocks for all tests in this class."""
        # Define the mock config directly instead of calling a fixture
        cls.mock_config_content = {
            'tool': {'name': 'malware_analysis_tool', 'version': '1.0.0'},
            'configuration': {
                'parameters': {
                    'virustotal_api_key': {'type': 'string', 'required': False, 'default': None},
                    'hybrid_analysis_api_key': {'type': 'string', 'required': False, 'default': None},
                    'vt_api_url': {'type': 'string', 'default': 'https://www.testvt.com/api/v3'},
                    'ha_api_url': {'type': 'string', 'default': 'https://www.testha.com/api/v2'},
                    'request_timeout': {'type': 'number', 'default': 5}
                },
                'dependencies': ['requests>=2.25.1', 'python-dotenv>=0.19.0']
            }
        }
        # Create a dummy tool.yaml for loading
        with open(TOOL_CONFIG_PATH, 'w') as f:
            yaml.dump(cls.mock_config_content, f)

        # Mock environment variables
        cls.env_patcher = patch.dict(
            os.environ,
            {
                "VIRUSTOTAL_API_KEY": "test_vt_key_env",
                "HYBRID_ANALYSIS_API_KEY": "test_ha_key_env",
            },
            clear=True,
        )
        cls.env_patcher.start()

        # Mock requests globally for the class
        cls.requests_patcher = patch(
            "tools.malware_analysis_tool.malware_analysis_tool.requests.request"
        )
        cls.mock_requests = cls.requests_patcher.start()

    @classmethod
    def tearDownClass(cls):
        """Clean up mocks after all tests."""
        cls.env_patcher.stop()
        cls.requests_patcher.stop()
        # Clean up dummy config file
        if TOOL_CONFIG_PATH.exists():
            TOOL_CONFIG_PATH.unlink()

    def setUp(self):
        """Reset mocks before each test."""
        self.mock_requests.reset_mock()
        # Default successful response setup - individual tests can override
        self.mock_response = MagicMock()
        self.mock_response.status_code = 200
        self.mock_response.text = '{"success": true}'
        self.mock_response.raise_for_status.return_value = None
        self.mock_requests.return_value = self.mock_response

        # Instantiate the tool - loads config and keys from mocked env/file
        self.tool = MalwareAnalysisTool()
        # Ensure URLs are loaded correctly from mock config
        self.vt_base_url = self.mock_config_content["configuration"]["parameters"][
            "vt_api_url"
        ]["default"]
        self.ha_base_url = self.mock_config_content["configuration"]["parameters"][
            "ha_api_url"
        ]["default"]
        self.timeout = self.mock_config_content["configuration"]["parameters"][
            "request_timeout"
        ]["default"]

    # --- Initialization Tests ---
    def test_initialization_with_env_keys(self):
        """Test tool initialization correctly loads keys from environment."""
        self.assertEqual(self.tool.virustotal_api_key, "test_vt_key_env")
        self.assertEqual(self.tool.hybrid_analysis_api_key, "test_ha_key_env")
        self.assertEqual(self.tool.vt_api_url, self.vt_base_url)
        self.assertEqual(self.tool.ha_api_url, self.ha_base_url)
        self.assertEqual(self.tool.request_timeout, self.timeout)

    @patch.dict(os.environ, {}, clear=True)
    def test_initialization_without_env_keys_warning(self):
        """Test that warnings are logged if keys are missing."""
        with (
            patch(
                "tools.malware_analysis_tool.malware_analysis_tool.yaml.safe_load"
            ) as mock_yaml_load,
            patch(
                "tools.malware_analysis_tool.malware_analysis_tool.logger"
            ) as mock_logger,
        ):
            mock_yaml_load.return_value = self.mock_config_content
            tool_no_keys = MalwareAnalysisTool()
            self.assertIsNone(tool_no_keys.virustotal_api_key)
            self.assertIsNone(tool_no_keys.hybrid_analysis_api_key)
            mock_logger.warning.assert_any_call(
                "VirusTotal API key not found. VirusTotal analysis will be skipped."
            )
            mock_logger.warning.assert_any_call(
                "Hybrid Analysis API key not found. Hybrid Analysis will be skipped."
            )

    # --- Static Analysis (Hash Lookup) Tests ---
    def test_run_static_analysis_clean_sha256_hash(self):
        """Test static analysis with a clean SHA256 hash."""
        self.mock_requests.side_effect = [
            MagicMock(
                status_code=200,
                text=VT_HASH_RESPONSE_CLEAN,
                raise_for_status=lambda: None,
            ),
            MagicMock(
                status_code=200,
                text=HA_HASH_RESPONSE_CLEAN,
                raise_for_status=lambda: None,
            ),
        ]

        result = self.tool._run(
            content_or_path=SAMPLE_CLEAN_SHA256, analysis_type="static"
        )

        # Check key parts instead of exact line match
        self.assertIn("**Target:**", result)
        self.assertIn(SAMPLE_CLEAN_SHA256, result)
        self.assertIn("**Analysis Type:** static", result)
        self.assertIn(VT_HASH_RESPONSE_CLEAN, result)
        self.assertIn(HA_HASH_RESPONSE_CLEAN, result)
        self.assertEqual(self.mock_requests.call_count, 2)
        # Check VT call
        self.mock_requests.assert_any_call(
            "get",
            f"{self.vt_base_url}/files/{SAMPLE_CLEAN_SHA256}",
            headers=unittest.mock.ANY,
            params=None,
            json=None,
            data=None,
            files=None,
            timeout=self.timeout,
        )
        # Check HA call
        self.mock_requests.assert_any_call(
            "post",
            f"{self.ha_base_url}/search/hash",
            headers=unittest.mock.ANY,
            params=None,
            data={"hash": SAMPLE_CLEAN_SHA256},
            files=None,
            timeout=self.timeout,
        )

    def test_run_static_analysis_eicar_hash_malicious(self):
        """Test static analysis with the EICAR SHA256 hash (expected malicious)."""
        # Configure mocks to return malicious responses for EICAR hash
        self.mock_requests.side_effect = [
            MagicMock(
                status_code=200,
                text=VT_HASH_RESPONSE_MALICIOUS,
                raise_for_status=lambda: None,
            ),
            MagicMock(
                status_code=200,
                text=HA_HASH_RESPONSE_MALICIOUS,
                raise_for_status=lambda: None,
            ),
        ]

        result = self.tool._run(content_or_path=EICAR_SHA256, analysis_type="static")

        # Check key parts instead of exact line match
        self.assertIn("**Target:**", result)
        self.assertIn(EICAR_SHA256, result)
        self.assertIn("**Analysis Type:** static", result)
        self.assertIn(
            f"**VirusTotal Results:**\n```json\n{VT_HASH_RESPONSE_MALICIOUS}\n```",
            result,
        )
        self.assertIn(
            f"**Hybrid Analysis Results:**\n```json\n{HA_HASH_RESPONSE_MALICIOUS}\n```",
            result,
        )
        self.assertEqual(self.mock_requests.call_count, 2)
        # Check VT call
        self.mock_requests.assert_any_call(
            "get",
            f"{self.vt_base_url}/files/{EICAR_SHA256}",
            headers={"x-apikey": "test_vt_key_env", "Accept": "application/json"},
            params=None,
            json=None,
            data=None,
            files=None,
            timeout=self.timeout,
        )
        # Check HA call
        self.mock_requests.assert_any_call(
            "post",
            f"{self.ha_base_url}/search/hash",
            headers={
                "api-key": "test_ha_key_env",
                "User-Agent": unittest.mock.ANY,
                "Accept": "application/json",
            },
            params=None,
            data={"hash": EICAR_SHA256},
            files=None,
            timeout=self.timeout,
        )

    def test_run_auto_analysis_with_hash(self):
        """Test auto analysis correctly identifies hash and performs static lookup."""
        self.mock_requests.side_effect = [
            MagicMock(
                status_code=200,
                text=VT_HASH_RESPONSE_CLEAN,
                raise_for_status=lambda: None,
            ),
            MagicMock(
                status_code=200,
                text=HA_HASH_RESPONSE_CLEAN,
                raise_for_status=lambda: None,
            ),
        ]
        result = self.tool._run(
            content_or_path=SAMPLE_CLEAN_SHA256, analysis_type="auto"
        )
        # Check key parts instead of exact line match
        self.assertIn("**Target:**", result)
        self.assertIn(SAMPLE_CLEAN_SHA256, result)
        self.assertIn(
            "**Analysis Type:** static", result
        )  # Auto defaults to static for hash
        self.assertEqual(self.mock_requests.call_count, 2)

    # --- Static Analysis (File Path) Tests ---
    def test_run_static_analysis_with_file_path(self):
        """Test static analysis uses file hash when given a path."""
        self.mock_requests.side_effect = [
            MagicMock(
                status_code=200,
                text=VT_HASH_RESPONSE_CLEAN,
                raise_for_status=lambda: None,
            ),
            MagicMock(
                status_code=200,
                text=HA_HASH_RESPONSE_CLEAN,
                raise_for_status=lambda: None,
            ),
        ]

        file_content = b"clean file content for hashing"
        expected_hash = hashlib.sha256(file_content).hexdigest()

        with tempfile.NamedTemporaryFile(delete=False) as tmpfile:
            tmpfile.write(file_content)
            filepath = tmpfile.name

        try:
            result = self.tool._run(content_or_path=filepath, analysis_type="static")
            # Check key parts instead of exact line match
            self.assertIn("**Target:**", result)
            self.assertIn(filepath, result)
            self.assertIn(expected_hash, result)
            self.assertIn("**Analysis Type:** static", result)
            self.assertEqual(self.mock_requests.call_count, 2)
            # Check that the HASH was used for API calls
            self.mock_requests.assert_any_call(
                "get",
                f"{self.vt_base_url}/files/{expected_hash}",
                headers=unittest.mock.ANY,
                params=None,
                json=None,
                data=None,
                files=None,
                timeout=self.timeout,
            )
            self.mock_requests.assert_any_call(
                "post",
                f"{self.ha_base_url}/search/hash",
                headers=unittest.mock.ANY,
                params=None,
                data={"hash": expected_hash},
                files=None,
                timeout=self.timeout,
            )
        finally:
            os.remove(filepath)  # Clean up temp file

    def test_run_auto_analysis_with_file_path(self):
        """Test auto analysis uses file hash when given a path."""
        self.mock_requests.side_effect = [
            MagicMock(
                status_code=200,
                text=VT_HASH_RESPONSE_CLEAN,
                raise_for_status=lambda: None,
            ),
            MagicMock(
                status_code=200,
                text=HA_HASH_RESPONSE_CLEAN,
                raise_for_status=lambda: None,
            ),
        ]
        with tempfile.NamedTemporaryFile(delete=False, mode="wb") as tmpfile:
            tmpfile.write(b"clean file content auto")
            filepath = tmpfile.name
        expected_hash = hashlib.sha256(b"clean file content auto").hexdigest()

        try:
            result = self.tool._run(content_or_path=filepath, analysis_type="auto")
            # Check key parts instead of exact line match
            self.assertIn("**Target:**", result)
            self.assertIn(filepath, result)
            self.assertIn(expected_hash, result)
            self.assertIn(
                "**Analysis Type:** static", result
            )  # Auto defaults to static hash check for files
            self.assertEqual(self.mock_requests.call_count, 2)
        finally:
            os.remove(filepath)

    # --- Dynamic Analysis Tests (Placeholders) ---
    def test_run_dynamic_analysis_with_file_path_placeholder(self):
        """Test dynamic analysis with a file path (uses placeholder message)."""
        with tempfile.NamedTemporaryFile(delete=False, mode="wb") as tmpfile:
            tmpfile.write(b"file for dynamic analysis")
            filepath = tmpfile.name

        try:
            result = self.tool._run(content_or_path=filepath, analysis_type="dynamic")
            # Check key parts instead of exact line match
            self.assertIn("**Target:**", result)
            self.assertIn(filepath, result)
            self.assertIn("**Analysis Type:** dynamic", result)
            self.assertIn(
                "**VirusTotal Results:**\n```json\nDynamic analysis (file submission) for VirusTotal not yet implemented.\n```",
                result,
            )
            self.assertIn(
                "**Hybrid Analysis Results:**\n```json\nDynamic analysis (file submission) for Hybrid Analysis not yet implemented.\n```",
                result,
            )
            self.mock_requests.assert_not_called()  # No API calls for placeholder
        finally:
            os.remove(filepath)

    # --- Error Handling Tests ---
    def test_run_dynamic_analysis_non_file_error(self):
        """Test dynamic analysis fails if input is not a file."""
        result = self.tool._run(
            content_or_path="not_a_real_file", analysis_type="dynamic"
        )
        self.assertEqual(
            result,
            "Error: Dynamic analysis requires a valid file path. Input 'not_a_real_file' is not a file.",
        )
        self.mock_requests.assert_not_called()

    def test_run_invalid_input_auto(self):
        """Test auto analysis fails for input that is neither hash nor file."""
        result = self.tool._run(
            content_or_path="invalid input string", analysis_type="auto"
        )
        self.assertEqual(
            result,
            "Error: Input 'invalid input string' is not a recognized hash or a valid file path.",
        )
        self.mock_requests.assert_not_called()

    def test_run_invalid_input_static(self):
        """Test static analysis fails for input that is neither hash nor file."""
        result = self.tool._run(
            content_or_path="invalid input string", analysis_type="static"
        )
        self.assertEqual(
            result,
            "Error: Static analysis requires a valid hash or file path. Input 'invalid input string' is neither.",
        )
        self.mock_requests.assert_not_called()

    def test_run_api_error_handling_vt(self):
        """Test handling of API errors from VirusTotal."""
        # Simulate VT 404 Not Found, HA success
        mock_vt_error = MagicMock(spec=requests.Response)
        mock_vt_error.status_code = 404
        mock_vt_error.text = VT_ERROR_RESPONSE
        mock_vt_error.raise_for_status.side_effect = requests.exceptions.HTTPError(
            response=mock_vt_error
        )
        mock_ha_success = MagicMock(
            status_code=200, text=HA_HASH_RESPONSE_CLEAN, raise_for_status=lambda: None
        )

        self.mock_requests.side_effect = [mock_vt_error, mock_ha_success]

        result = self.tool._run(
            content_or_path=SAMPLE_CLEAN_SHA256, analysis_type="static"
        )
        self.assertIn(
            f"Error: VirusTotal API request failed (Status: 404): {VT_ERROR_RESPONSE}",
            result,
        )
        self.assertIn(HA_HASH_RESPONSE_CLEAN, result)  # HA should still be present
        self.assertEqual(self.mock_requests.call_count, 2)

    def test_run_api_error_handling_ha(self):
        """Test handling of API errors from Hybrid Analysis."""
        # Simulate VT success, HA error
        mock_vt_success = MagicMock(
            status_code=200, text=VT_HASH_RESPONSE_CLEAN, raise_for_status=lambda: None
        )
        mock_ha_error = MagicMock(spec=requests.Response)
        mock_ha_error.status_code = 400
        mock_ha_error.text = HA_ERROR_RESPONSE
        mock_ha_error.raise_for_status.side_effect = requests.exceptions.HTTPError(
            response=mock_ha_error
        )

        self.mock_requests.side_effect = [mock_vt_success, mock_ha_error]

        result = self.tool._run(
            content_or_path=SAMPLE_CLEAN_SHA256, analysis_type="static"
        )
        self.assertIn(VT_HASH_RESPONSE_CLEAN, result)
        self.assertIn(
            f"Error: Hybrid Analysis API request failed (Status: 400): {HA_ERROR_RESPONSE}",
            result,
        )
        self.assertEqual(self.mock_requests.call_count, 2)

    def test_run_api_key_missing_skips_call(self):
        """Test that API calls are skipped if keys are missing."""
        with patch.dict(os.environ, {}, clear=True):  # Clear env vars
            with patch(
                "tools.malware_analysis_tool.malware_analysis_tool.logger"
            ):  # Suppress warnings
                tool_no_keys = MalwareAnalysisTool()

            result = tool_no_keys._run(
                content_or_path=SAMPLE_CLEAN_SHA256, analysis_type="static"
            )

            self.assertIn("**VirusTotal Results:**\n```json\nSkipped\n```", result)
            self.assertIn("**Hybrid Analysis Results:**\n```json\nSkipped\n```", result)
            self.mock_requests.assert_not_called()  # Ensure requests.request was never called

    def test_input_validation_error(self):
        """Test Pydantic validation failure."""
        invalid_kwargs = {"analysis_type": "static"}  # Missing 'content_or_path'
        result = self.tool._run(**invalid_kwargs)
        self.assertTrue(
            result.startswith("Error: Input validation failed:"),
            f"Unexpected result: {result}",
        )
        self.assertIn("Field required", result)
        self.mock_requests.assert_not_called()


# --- How to Run ---
# 1. Ensure pytest and pytest-mock are installed (`pip install pytest pytest-mock` or `poetry add --group test pytest pytest-mock`)
# 2. Run from the project root directory: `pytest tests/tools/test_malware_analysis_tool.py`
#    Or if using poetry: `poetry run pytest tests/tools/test_malware_analysis_tool.py`
